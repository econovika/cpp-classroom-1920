= Семинар №1. Организация разработки программ на С++

== Информация о семинаристах

- Роман Голышев, гитхаб: https://github.com/fedochet[@fedochet]
- Филипп Гарбовой, гитхаб: https://github.com/Sviftel[@Sviftel]
- Егор Башарин, гитхаб: https://github.com/eaniconer[@eaniconer]

== Цели занятия

- Научиться компилировать простые программы на C++;
- Научиться определять и объявлять переменные встроенных типов;
- Поработать с функциями, циклами и условиями;
- Освоить ввод/вывод в консоль и в файл стандартными средствами C++.

== Что вам нужно установить и что нужно знать

.Много деталей
[%collapsible]
====

Что нужно для курса:

- Набор инструментов для компиляции C++.
    - Компилятор.
    - Сборщики `Make` и `CMake`.
- Установленный git и аккаунт на https://www.github.com.
- Редактор, чтобы редактировать код.

Процесс компиляции программ на `C++` важно понимать, чтобы уметь устранять ошибки. 
Чтобы лучше его прочувствовать, мы рекомендуем какое-то время компилировать ваш
код из командной строки, напрямую используя компилятор.

Тем не менее, при постоянной работе с `C++` удобнее использовать системы сборки. 
В этом курсе мы будем использовать `CMake`, и его тоже стоит установить.

Для компиляции вам понадобится на выбор: 

- Unix-like операционная система, установленный компилятор (g++ или clang++).
    * Это предпочтительная конфигурация для прохождения курса.
    * Компилятор, `CMake` и прочие требуемые программы устанавливаются с помощью пакетных менеджеров.
    * Гуглить `install <tool> on <OS>`, например `install g++ on ubuntu 16.04`.
- Операционная система Windows, установленная Visual Studio и её компилятор или аналоги.
    * Самый простой путь -- установить Visual Studio и пользоваться ей. Она содержит компилятор и CMake.
    * Путь сложнее -- использовать mingw или cygwin. Погуглите, как это установить.

Вышеописанные пути занимают довольно долго времени. Если у вас нет возможности быстро настроить окружение, на первом семинаре вы можете программировать в repl.it -- это онлайн-IDE.

====

== Компиляция программ на C++ (для Unix)

Создать исполняемый файл из файла с исходным кодом в `main.cpp`.
Результат: исполняемый файл `a.out`.

[code]
----

$ g++ main.cpp
----

Запустить исполняемый файл.

[code]
----
$ ./a.out
----

Мы будем всегда указывать флаги о дополнительных предупреждениях от компилятора.

[code]
----
$ g++ main.cpp -Wall -Werror
----

== Зачем нужны заголовочные файлы?

.На случай, если этого ещё не покрыла лекция.
[%collapsible]
====

Одна из основных целей хедеров -- делить объявления функций между различными единицами компиляции.

Особенность компиляторов `C` и `C++` в том, что каждый `.c/.cpp` файл они компилируют *изолированно друг от друга*,
получая объектные файлы. Затем эти объектные файлы объединяются (линкуются) в итоговый исполняемый файл.

Допустим, у нас есть файлы `main.cpp` и `file.cpp`. В `file.cpp` реализованы функции для работы с файлами.

.file.cpp
[source,cpp]
----
...

string read_content(string const& file_name) { ... }

...
----

.main.cpp
[source,cpp]
----
int main() {
    cout << read_content("input.txt") << endl;
    return 0;
}
----

В `main.cpp` используется `read_content`. Компилятор компилирует `main.cpp` отдельно, поэтому он не может посмотреть
в `file.cpp` и проверить, что такая функция там есть и что у неё подходящая сигнатура.

Эта проблема решается с помощью использования заголовочных файлов и директив препроцессора `#include`.

Создадим заголовочный файл `file.hpp` с таким содержанием:

.file.hpp
[source,cpp]
----
#ifndef FILE_HPP
#define FILE_HPP

...

string read_content(string const& file);

...

#endif
----

Модифицируем файлы `main.cpp` и `file.cpp`, чтобы они оба включали заголовочный файл в себя:

.file.cpp
[source,cpp]
----
#include "file.hpp"

...

string read_content(string const& file_name) { ... }

...
----

.main.cpp
[source,cpp]
----
#include "file.hpp"

int main() {
    cout << read_content("input.txt") << endl;
    return 0;
}
----

Когда компилятор будет обрабатывать эти файлы, он заменит `#include`-ы на содержимое
файлов, на которые они указывают. Т.о. `file.cpp` и `main.cpp` будут выглядеть так:

.file.cpp
[source,cpp]
----
#ifndef FILE_HPP
#define FILE_HPP

...

string read_content(string const& file);

...

#endif

...

string read_content(string const& file_name) { ... }

...
----

.main.cpp
[source,cpp]
----
#ifndef FILE_HPP
#define FILE_HPP

...

string read_content(string const& file);

...

#endif

int main() {
    cout << read_content("input.txt") << endl;
    return 0;
}
----

Теперь у компилятора есть объявления функции `read_content` во всех местах, где её используют.
Объявления достаточно, чтобы компилятор смог создать объектный файл.

Если при линковке определение функции так и не будет найдено, то компилятор (линковщик)
выдаст ошибку линковки вида `undefined reference to file_content(string const&) in main.cpp`.

****
У компилятора `g++` есть опция `-E`, позволяющая посмотреть, как будут выглядеть единицы компиляции
после препроцессинга.
****

====

== Задачи

[NOTE]
====
Если вы видите несоответствие между заданием здесь и в коде (в тестах):

1. Сообщите об этом преподавателю.
2. Ориентируйтесь на код, если нет жестких противоречий.
====

Требования к задачам: 

- Используйте `cin` и `cout` для вывода при выполнении задач, это необходимо для тестов; не используйте другие способы вывода (в том числе `printf` и прочее), если этого не сказано явно.

=== Задача №1. Hello World

Напишите и скомпилируйте программу с функцией `say_hello`, выводящей `Hello, world!` в стандартный вывод.

Сигнатура функции:

[source,cpp]
----
void say_hello();
----

Объявите функцию в заголовочном файле `say_hello.hpp`, а её тело реализуйте в файле `say_hello.cpp`.

=== Задача №2. Fizz Buzz

Напишите функцию, которая выводит на экран числа от `1` до `n`. Вместо чисел, кратных трем, программа должна выводить слово `Fizz`, а вместо чисел, кратных пяти — слово `Buzz`. Если число кратно пятнадцати, то программа должна выводить слово `FizzBuzz`.

Сигнатура функции: 

[source,cpp]
----
void fizzbuzz(uint64_t n);
----

Объявите функцию в заголовочном файле `fizzbuzz.hpp`, а её тело реализуйте в файле `fizzbuzz.cpp`.

.Пример работы программы, вызывающей `fizzbuzz(15)`: 
[%collapsible]
====

[source,cpp]
----
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
----
====

=== Задача №3

Напишите функцию `compute_fib`, считывающую из `input.txt` целое `N` и возвращающую `N`-ное число Фибоначчи.

Число фибоначчи рекомендуется считать нерекурсивно.

Сигнатура функции: 

[source,cpp]
----
int64_t compute_fib();
----

Объявите функцию в заголовочном файле `compute_fib.hpp`, а её тело реализуйте в файле `compute_fib.cpp`.

