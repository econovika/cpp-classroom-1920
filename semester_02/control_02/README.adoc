= Parser Combinators
:source-highlighter: highlightjs
:revealjs_hash: true
:icons: font

C++ часть 2, контрольная работа #2

ИТМО, 30.03.2020

== Как сдавать контрольную

* Вы должны запушить ваше решение в ветку `sem_2_control_02`
* Решение должно лежать в файле `parsers.hpp`

== Как запускать тесты

В файле `smoke.cpp` есть дифайны для каждого из заданий.

Чтобы активировать тесты, вам нужно раскомментировать дифайн.

== Что такое парсер-комбинаторы?

Есть несколько подходов к парсингу структурированных текстов:

* Написание парсера руками.
* Генерация парсера на основе грамматики (YACC, BISON, и т.д.).

ifdef::backend-revealjs[=== !]

* Комбинация простых парсеров в более сложные с использованием парсер-комбинаторов.
** `ch('a')` парсит только символ 'a'.
** `many(parser)` парсит 0 или больше вхождений того, что парсит parser.
** `seq(parser1, parser2)` использует сначала parser1, потом parser2.

=== Стандартный набор

Для комфортного написания правил парсинга обычно требуются:

* Базовые блоки, т.е. простейшие парсеры.
** ch(char)
** str(std::string)
** regex(std::regex)
** ...

ifdef::backend-revealjs[=== !]

* Комбинаторы, позволяющие их объединять.
** opt - опциональный элемент.
** many - 0 или больше вхождений элемента.
** alt - один из нескольких элементов.
** seq - фиксированная последовательность элементов.
** Комбинатор-трансформер, который трансформирует результат парсинга в пользовательский тип.

== Задание

Написать простую библиотеку парсер-комбинаторов на C++.

Каждый парсер должен иметь метод `parse(string_view)`, который пытается разобрать входную строку и возвращает `result<T>`, где `T` - это тип элемента, который парсит этот конкретный парсер.

ifdef::backend-revealjs[=== !]

`result<T>` позволяет:

* Узнать, был ли разбор успешным.
* Получить результат разбора.
* Получить кусок строки, который остался неразобранным.

=== Пример создания парсера

[source,cpp]
----
auto const seq_parser = control_2::seq(
    control_2::str("hello"),
    control_2::many(control_2::ch(' ')),
    control_2::str("world"),
    control_2::opt(control_2::ch('!'))
);
----


=== Пример использования парсера

[source,cpp]
----
auto const result = seq_parser.parse("hello     world!");

assert(result && result.remaining().empty());
assert(result.value() ==
    std::make_tuple(
        "hello",
        std::vector<char>(5, ' '),
        "world",
        std::optional{'!'}
    )
);
----

== Подсказки

Здесь даны подсказки про вещи, которые может быть долго или сложно гуглить самому.

ifdef::backend-revealjs[=== !]

Q: Как передать елементы std::tuple в метод по одному (как аргументы)?

A: Ипользуйте std::apply(method, tuple).

ifdef::backend-revealjs[=== !]

Q: Как объединить несколько std::tuple в одну с сохранением типа?

A: Используйте std::tuple_cat(tuple1, tuple2, …, tupleN).

== Задача 0 (0.5 баллов)

Напишите основу вашей библиотеки - простейшие парсеры и класс `result<T>`.

=== Список парсеров:

* ch(char) - пытается распарсить один символ.
* str(std::string) - пытается распарсить конкретную строку.

ifdef::backend-revealjs[=== !]

NB #1: подразумевается, что строчка, которую мы парсим, переживает сам парсинг и возврат результата.

ifdef::backend-revealjs[=== !]

NB #2: не создавайте класс `ch`, вместо этого воспользуйтесь статической функцией `ch`, которая что-то возвращает.

Тесты заточены на то, что парсеры создаются с помощью статических функций.

ifdef::backend-revealjs[=== !]

NB #3: не забывайте про константность, мув-семантику и ссылки!

ifdef::backend-revealjs[=== !]

Методы парсеров:

* result<T> parse(string_view) - пытается разобрать строчку.
* T - разный для каждого парсера; у ch - char, у str - string.

ifdef::backend-revealjs[=== !]

Методы result<T>:

** явная конверсия к bool.
** string_view remaining() - возвращает остаток строки, который не был разобран.
** T value() - возвращает разобранное значение или кидает исключение, если его нет.

== Задача 1 (0.5 балл)

Напишите первые комбинаторы - opt и many.

ifdef::backend-revealjs[=== !]

opt(Parser parser) - пытается разобрать строку, используя parser. В любом случае завершает парсинг успешно.

Тип результата - optional от типа результата Parser (0.25 балла).

ifdef::backend-revealjs[=== !]

many(Parser parser) - разбирает строку parser-ом до первой неудачи.

Тип результата - vector<T>, где T - тип результата Parser.

Если parser завершился удачно, но при этом не продвинулся по строке, то many завершает работу (0.25 балла).

== Задача 2 (1 балл)

Напишите продвинутые комбинаторы - rule и alt.

=== rule

rule(Parser parser, Tranformer trans) - выполняет разбор с помощью parser.

Если он был успешен, трансформирует результат с помощью trans и возвращает его (0.3 балла).

=== alt

alt(Parser... parsers) - пытается разобрать строку, поочередно используя переданные ему парсеры.

Первый же успешный разбор возвращается; в случае, когда ни один из парсеров не завершился успешно, возвращается неудача. (0.7 баллов).

== Задача 3 (1 балл)

Напишите самый важный комбинатор - seq.

=== Seq

seq(Parser... parsers) - последовательно использует переданные парсеры для разбора строки.

Каждому следующему парсеру передается то, что осталось после разбора предыдущим.

ifdef::backend-revealjs[=== !]

Если хотя бы один парсер в цепочке завершается с ошибкой, то комбинатор тоже возвращает ошибку.

Если все парсеры выполнились успешно, то результатом является tuple, содержащий их результаты.
