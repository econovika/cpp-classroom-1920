= SFINAE
:revealjs_theme: white
:source-highlighter: highlightjs
:revealjs_hash: true
:icons: font

Segmentation Fault Is Not An Error

C++ часть 2, cеминар #5

ИТМО, 16.03.2020


////
== Recap прошлого семинара

- Форвардинг аргументов в хэндлер.

  void fire(Args&&...args) {
    ...
    for (auto& h : handlers_) {
      // что достанется второму хэндлеру?
      h(std::forward<Args>(args)...);
    }
  }

== Recap прошлого семинара

- Хранение указателя на лист и итератора на лист.

  ```cpp
  list<string> s {"hello", "world"};
  auto it = s.begin();

  auto moved_s = std::move(s);

  // итератор теперь указывает в другой лист
  s.erase(it);
  ```

== Recap прошлого семинара

- Написание конструкторов/операторов вручную.

  ```cpp
  struct event {
    string topic_;
    vector<handler_t> handlers_;

    event(event &const e) = delete;
    event(event&& e):
      topic_(std::move(e.topic_)),
      handlers_(std::move(e.handlers_)) {}

... // операторы
}
```

== Recap прошлого семинара

- Написание конструкторов/операторов вручную.

  ```cpp
  struct event {
    string topic_;
    vector<handler_t> handlers_;

    event(event&&) = default;
    ... // операторы так же
  }
  ```


////
== Цели и задачи занятия

- Попрактиковаться в использовании SFINAE для реализации собственного алгоритма выбора перегрузки шаблонной функции
- Реализовать библиотеку для сериализации/десериализации контейнеров и POD типов с возможностью расширить этот набор пользовательскими типами


== Есть ли вопросы про SFINAE?

Здесь можно ответить на них.
////

Вещи, которые нужно помнить, когда вы используете SFINAE.

- **Не используйте SFINAE.** Сложный код сложно понимать и поддерживать.
- `#include <type_traits>` - ваш лучший друг; смотрите туда, прежде чем писать велосипед.
- Чтобы получить переменную типа `T`, используйте `std::declval<T>()`.
- `decltype(std::declval(T).size()) ~~ T::size_type`.
- Более читаемо, чем `(*(T*)(nullptr))` или аналоги.
////
////
== type_traits, соглашения

`has_begin_end` из лекции - тип, позволяющий узнавать свойства других типов.

Сущности, которые манипулируют типами и что-то выдают, называют **метафункциями**.

Примеры метафункций: `enable_if`, `remove_reference`, и т.д.

. . .

Чтобы не писать `typename` слишком часто, стали вводить специальные вспомогательные функции.

- `..._t` - возвращает тип.
- `..._v` - возвращает значение.

Данного соглашения стоит придерживаться и в своих метафункциях.

== type_traits, соглашения. Мотивирующий пример (до)

```cpp
static_assert(
        std::is_same<
            typename std::decay<T>::type,
            typename std::decay<U>::type
        >::value
        || std::is_base_of<
            typename std::decay<T>::type,
            typename std::decay<U>::type
        >::value
    );
```

== type_traits, соглашения. Мотивирующий пример (после)

```cpp
static_assert(
    std::is_same_v<std::decay_t<T>,std::decay_t<U>>
    || std::is_base_of_v<std::decay_t<T>, std::decay_t<U>>
);

```

На то, как объявлять такие функции, можно посмотреть в стандартной библиотеке.
////

== Задача 1 (0.25 балла)

Разминка! Пора написать функции с хитрыми перегрузками.

ifdef::backend-revealjs[=== !]

Реализуйте функцию `distance`, принимающую два итератора и возвращающую расстояние между ними.

Для  итераторов с произвольным доступом асимптотика должна быть O(1), для всех остальных - O(n).

ifdef::backend-revealjs[=== !]

[WARNING]
====

Не используйте `if constexpr`!

====

== Сериализация

- В программе имеется некоторый объект
- Состояние объекта сохраняется в блок байтов/текста/… (сериализация)
- Из этого блока можно восстановить эквивалентный объект (десериализация)
- Эквивалентность, как и оператор == определяются каждым классом самостоятельно

== Задача 2 (0.5 балл)

Реализуйте функции, которые могут сериализовать и десериализовать любые POD типы.

[source,cpp]
----
void serialize(std::ostream& out, T const& obj)
void deserialize(std::istream& in, T &obj)
----

Если T - не POD тип, то покажите ошибку компиляции “Type is not serializable”.

Примеры вызова `serialize`, `deserialize` смотрите в тестах.

== Задача 3 (1 балл)

* Поддержите в функциях `serialize` и `deserialize` возможность сериализовать контейнеры POD типов.
* Контейнер - класс, внутри которого определен тип `iterator` и `const_iterator`.
* Теперь вы должны быть способны сериализовывать сложные типы (например, `vector<string>`).

== Задача 4 (1 балл)

- Добавьте возможность сериализовывать произвольный пользовательский тип с помощью написания для него функциий `serialize` и `deserialize`.
- Добавьте возможность сериализовывать `std::map` и `std::unordered_map`.